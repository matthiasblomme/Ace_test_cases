BROKER SCHEMA com.ibm.test.dac


CREATE COMPUTE MODULE TestArrayDelete_Compute_JEB
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		-- CALL CopyMessageHeaders();
		-- CALL CopyEntireMessage();
		
		--Input { "field1": "content1", "field2": "content2", "array1": ["arrayContent1", "arrayContent2", "arrayContent3"], "field3": "content3" } 
		--Output { "field1": "content1", "field2": "content2", "array1": "", "field3": "content3" } 
		
		DECLARE rEnv		REFERENCE TO Environment;
		CREATE FIELD rEnv.Variables;
		DECLARE rEnvVar		REFERENCE TO rEnv.Variables;
		
		CREATE LASTCHILD OF rEnvVar DOMAIN 'JSON';
		
		SET rEnvVar.JSON.Data.test1 = InputRoot.JSON.Data;
		SET rEnvVar.JSON.Data.test2 = InputRoot.JSON.Data;
		SET rEnvVar.JSON.Data.test3 = InputRoot.JSON.Data;
		SET rEnvVar.JSON.Data.test4 = InputRoot.JSON.Data;
		
		DECLARE rTest1		REFERENCE TO rEnvVar.JSON.Data.test1;
		DECLARE rTest2		REFERENCE TO rEnvVar.JSON.Data.test2;
		DECLARE rTest3		REFERENCE TO rEnvVar.JSON.Data.test3;
		DECLARE rTest4		REFERENCE TO rEnvVar.JSON.Data.test4;
				
		--Original Test1 - This should delete the array entirely, and does
		SET rTest1.array1 = null;
		
		--Original Test2/Test3 - This will delete the array and create an empty element, not an empty array.
		DELETE FIELD rTest2.array1;	
		CREATE FIELD rTest2.array1 VALUE '';
				
		--Original Test4 - Try to avoid using CARDINALITY, if you can. HUGE performance issues if there are large arrays
--		DECLARE elementCount INTEGER CARDINALITY(Environment.variables.test.array1.*[]);
--		DECLARE i INTEGER 1;
--		WHILE i < elementCount +1 DO
--			DELETE LASTCHILD OF Environment.variables.test4.array1;
--			SET i = i+1;
--		END WHILE;

		--New Test
		WHILE EXISTS(rTest3.array1.Item[]) DO
			DELETE FIELD rTest3.array1.Item[<];
		END WHILE;
			
		--New Test		
		SET rTest4.array1 = null;
		CREATE FIELD rTest4.array1 IDENTITY(JSON.Array) array1;
				
		
		CREATE LASTCHILD OF OutputRoot DOMAIN 'JSON';		
		SET OutputRoot.JSON.Data = rEnvVar.JSON.Data;
		
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;
